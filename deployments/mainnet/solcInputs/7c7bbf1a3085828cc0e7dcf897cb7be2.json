{
  "language": "Solidity",
  "sources": {
    "apps/avai/src/contracts/openzep/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n  /**\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n   *\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n   * {RoleAdminChanged} not being emitted signaling this.\n   *\n   * _Available since v3.1._\n   */\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n\n  /**\n   * @dev Emitted when `account` is granted `role`.\n   *\n   * `sender` is the account that originated the contract call, an admin role\n   * bearer except when using {AccessControl-_setupRole}.\n   */\n  event RoleGranted(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Emitted when `account` is revoked `role`.\n   *\n   * `sender` is the account that originated the contract call:\n   *   - if using `revokeRole`, it is the admin role bearer\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n   */\n  event RoleRevoked(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _HEX_SYMBOLS = '0123456789abcdef';\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return '0';\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return '0x00';\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = '0';\n    buffer[1] = 'x';\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, 'Strings: hex length insufficient');\n    return string(buffer);\n  }\n}\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n  struct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n  }\n\n  mapping(bytes32 => RoleData) private _roles;\n\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n  /**\n   * @dev Modifier that checks that an account has a specific role. Reverts\n   * with a standardized message including the required role.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   *\n   * _Available since v4.1._\n   */\n  modifier onlyRole(bytes32 role) {\n    _checkRole(role, _msgSender());\n    _;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return\n      interfaceId == type(IAccessControl).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    override\n    returns (bool)\n  {\n    return _roles[role].members[account];\n  }\n\n  /**\n   * @dev Revert with a standard message if `account` is missing `role`.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   */\n  function _checkRole(bytes32 role, address account) internal view {\n    if (!hasRole(role, account)) {\n      revert(\n        string(\n          abi.encodePacked(\n            'AccessControl: account ',\n            Strings.toHexString(uint160(account), 20),\n            ' is missing role ',\n            Strings.toHexString(uint256(role), 32)\n          )\n        )\n      );\n    }\n  }\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n    return _roles[role].adminRole;\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) public virtual override {\n    require(\n      account == _msgSender(),\n      'AccessControl: can only renounce roles for self'\n    );\n\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event. Note that unlike {grantRole}, this function doesn't perform any\n   * checks on the calling account.\n   *\n   * [WARNING]\n   * ====\n   * This function should only be called from the constructor when setting\n   * up the initial roles for the system.\n   *\n   * Using this function in any other way is effectively circumventing the admin\n   * system imposed by {AccessControl}.\n   * ====\n   */\n  function _setupRole(bytes32 role, address account) internal virtual {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Sets `adminRole` as ``role``'s admin role.\n   *\n   * Emits a {RoleAdminChanged} event.\n   */\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n    bytes32 previousAdminRole = getRoleAdmin(role);\n    _roles[role].adminRole = adminRole;\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\n  }\n\n  function _grantRole(bytes32 role, address account) private {\n    if (!hasRole(role, account)) {\n      _roles[role].members[account] = true;\n      emit RoleGranted(role, account, _msgSender());\n    }\n  }\n\n  function _revokeRole(bytes32 role, address account) private {\n    if (hasRole(role, account)) {\n      _roles[role].members[account] = false;\n      emit RoleRevoked(role, account, _msgSender());\n    }\n  }\n}\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl {\n  bytes32 public constant TIMELOCK_ADMIN_ROLE =\n    keccak256('TIMELOCK_ADMIN_ROLE');\n  bytes32 public constant PROPOSER_ROLE = keccak256('PROPOSER_ROLE');\n  bytes32 public constant EXECUTOR_ROLE = keccak256('EXECUTOR_ROLE');\n  uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n  mapping(bytes32 => uint256) private _timestamps;\n  uint256 private _minDelay;\n\n  /**\n   * @dev Emitted when a call is scheduled as part of operation `id`.\n   */\n  event CallScheduled(\n    bytes32 indexed id,\n    uint256 indexed index,\n    address target,\n    uint256 value,\n    bytes data,\n    bytes32 predecessor,\n    uint256 delay\n  );\n\n  /**\n   * @dev Emitted when a call is performed as part of operation `id`.\n   */\n  event CallExecuted(\n    bytes32 indexed id,\n    uint256 indexed index,\n    address target,\n    uint256 value,\n    bytes data\n  );\n\n  /**\n   * @dev Emitted when operation `id` is cancelled.\n   */\n  event Cancelled(bytes32 indexed id);\n\n  /**\n   * @dev Emitted when the minimum delay for future operations is modified.\n   */\n  event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n  /**\n   * @dev Initializes the contract with a given `minDelay`.\n   */\n  constructor(\n    uint256 minDelay,\n    address[] memory proposers,\n    address[] memory executors\n  ) {\n    _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n    _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n    _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n    // deployer + self administration\n    _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n    _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n    // register proposers\n    for (uint256 i = 0; i < proposers.length; ++i) {\n      _setupRole(PROPOSER_ROLE, proposers[i]);\n    }\n\n    // register executors\n    for (uint256 i = 0; i < executors.length; ++i) {\n      _setupRole(EXECUTOR_ROLE, executors[i]);\n    }\n\n    _minDelay = minDelay;\n    emit MinDelayChange(0, minDelay);\n  }\n\n  /**\n   * @dev Modifier to make a function callable only by a certain role. In\n   * addition to checking the sender's role, `address(0)` 's role is also\n   * considered. Granting a role to `address(0)` is equivalent to enabling\n   * this role for everyone.\n   */\n  modifier onlyRoleOrOpenRole(bytes32 role) {\n    if (!hasRole(role, address(0))) {\n      _checkRole(role, _msgSender());\n    }\n    _;\n  }\n\n  /**\n   * @dev Contract might receive/hold ETH as part of the maintenance process.\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Returns whether an id correspond to a registered operation. This\n   * includes both Pending, Ready and Done operations.\n   */\n  function isOperation(bytes32 id) public view virtual returns (bool pending) {\n    return getTimestamp(id) > 0;\n  }\n\n  /**\n   * @dev Returns whether an operation is pending or not.\n   */\n  function isOperationPending(bytes32 id)\n    public\n    view\n    virtual\n    returns (bool pending)\n  {\n    return getTimestamp(id) > _DONE_TIMESTAMP;\n  }\n\n  /**\n   * @dev Returns whether an operation is ready or not.\n   */\n  function isOperationReady(bytes32 id)\n    public\n    view\n    virtual\n    returns (bool ready)\n  {\n    uint256 timestamp = getTimestamp(id);\n    return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n  }\n\n  /**\n   * @dev Returns whether an operation is done or not.\n   */\n  function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n    return getTimestamp(id) == _DONE_TIMESTAMP;\n  }\n\n  /**\n   * @dev Returns the timestamp at with an operation becomes ready (0 for\n   * unset operations, 1 for done operations).\n   */\n  function getTimestamp(bytes32 id)\n    public\n    view\n    virtual\n    returns (uint256 timestamp)\n  {\n    return _timestamps[id];\n  }\n\n  /**\n   * @dev Returns the minimum delay for an operation to become valid.\n   *\n   * This value can be changed by executing an operation that calls `updateDelay`.\n   */\n  function getMinDelay() public view virtual returns (uint256 duration) {\n    return _minDelay;\n  }\n\n  /**\n   * @dev Returns the identifier of an operation containing a single\n   * transaction.\n   */\n  function hashOperation(\n    address target,\n    uint256 value,\n    bytes calldata data,\n    bytes32 predecessor,\n    bytes32 salt\n  ) public pure virtual returns (bytes32 hash) {\n    return keccak256(abi.encode(target, value, data, predecessor, salt));\n  }\n\n  /**\n   * @dev Returns the identifier of an operation containing a batch of\n   * transactions.\n   */\n  function hashOperationBatch(\n    address[] calldata targets,\n    uint256[] calldata values,\n    bytes[] calldata datas,\n    bytes32 predecessor,\n    bytes32 salt\n  ) public pure virtual returns (bytes32 hash) {\n    return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n  }\n\n  /**\n   * @dev Schedule an operation containing a single transaction.\n   *\n   * Emits a {CallScheduled} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have the 'proposer' role.\n   */\n  function schedule(\n    address target,\n    uint256 value,\n    bytes calldata data,\n    bytes32 predecessor,\n    bytes32 salt,\n    uint256 delay\n  ) public virtual onlyRole(PROPOSER_ROLE) {\n    bytes32 id = hashOperation(target, value, data, predecessor, salt);\n    _schedule(id, delay);\n    emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n  }\n\n  /**\n   * @dev Schedule an operation containing a batch of transactions.\n   *\n   * Emits one {CallScheduled} event per transaction in the batch.\n   *\n   * Requirements:\n   *\n   * - the caller must have the 'proposer' role.\n   */\n  function scheduleBatch(\n    address[] calldata targets,\n    uint256[] calldata values,\n    bytes[] calldata datas,\n    bytes32 predecessor,\n    bytes32 salt,\n    uint256 delay\n  ) public virtual onlyRole(PROPOSER_ROLE) {\n    require(\n      targets.length == values.length,\n      'TimelockController: length mismatch'\n    );\n    require(\n      targets.length == datas.length,\n      'TimelockController: length mismatch'\n    );\n\n    bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n    _schedule(id, delay);\n    for (uint256 i = 0; i < targets.length; ++i) {\n      emit CallScheduled(\n        id,\n        i,\n        targets[i],\n        values[i],\n        datas[i],\n        predecessor,\n        delay\n      );\n    }\n  }\n\n  /**\n   * @dev Schedule an operation that is to becomes valid after a given delay.\n   */\n  function _schedule(bytes32 id, uint256 delay) private {\n    require(\n      !isOperation(id),\n      'TimelockController: operation already scheduled'\n    );\n    require(delay >= getMinDelay(), 'TimelockController: insufficient delay');\n    _timestamps[id] = block.timestamp + delay;\n  }\n\n  /**\n   * @dev Cancel an operation.\n   *\n   * Requirements:\n   *\n   * - the caller must have the 'proposer' role.\n   */\n  function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n    require(\n      isOperationPending(id),\n      'TimelockController: operation cannot be cancelled'\n    );\n    delete _timestamps[id];\n\n    emit Cancelled(id);\n  }\n\n  /**\n   * @dev Execute an (ready) operation containing a single transaction.\n   *\n   * Emits a {CallExecuted} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have the 'executor' role.\n   */\n  function execute(\n    address target,\n    uint256 value,\n    bytes calldata data,\n    bytes32 predecessor,\n    bytes32 salt\n  ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n    bytes32 id = hashOperation(target, value, data, predecessor, salt);\n    _beforeCall(id, predecessor);\n    _call(id, 0, target, value, data);\n    _afterCall(id);\n  }\n\n  /**\n   * @dev Execute an (ready) operation containing a batch of transactions.\n   *\n   * Emits one {CallExecuted} event per transaction in the batch.\n   *\n   * Requirements:\n   *\n   * - the caller must have the 'executor' role.\n   */\n  function executeBatch(\n    address[] calldata targets,\n    uint256[] calldata values,\n    bytes[] calldata datas,\n    bytes32 predecessor,\n    bytes32 salt\n  ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n    require(\n      targets.length == values.length,\n      'TimelockController: length mismatch'\n    );\n    require(\n      targets.length == datas.length,\n      'TimelockController: length mismatch'\n    );\n\n    bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n    _beforeCall(id, predecessor);\n    for (uint256 i = 0; i < targets.length; ++i) {\n      _call(id, i, targets[i], values[i], datas[i]);\n    }\n    _afterCall(id);\n  }\n\n  /**\n   * @dev Checks before execution of an operation's calls.\n   */\n  function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n    require(isOperationReady(id), 'TimelockController: operation is not ready');\n    require(\n      predecessor == bytes32(0) || isOperationDone(predecessor),\n      'TimelockController: missing dependency'\n    );\n  }\n\n  /**\n   * @dev Checks after execution of an operation's calls.\n   */\n  function _afterCall(bytes32 id) private {\n    require(isOperationReady(id), 'TimelockController: operation is not ready');\n    _timestamps[id] = _DONE_TIMESTAMP;\n  }\n\n  /**\n   * @dev Execute an operation's call.\n   *\n   * Emits a {CallExecuted} event.\n   */\n  function _call(\n    bytes32 id,\n    uint256 index,\n    address target,\n    uint256 value,\n    bytes calldata data\n  ) private {\n    (bool success, ) = target.call{value: value}(data);\n    require(success, 'TimelockController: underlying transaction reverted');\n\n    emit CallExecuted(id, index, target, value, data);\n  }\n\n  /**\n   * @dev Changes the minimum timelock duration for future operations.\n   *\n   * Emits a {MinDelayChange} event.\n   *\n   * Requirements:\n   *\n   * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n   * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n   */\n  function updateDelay(uint256 newDelay) external virtual {\n    require(\n      msg.sender == address(this),\n      'TimelockController: caller must be timelock'\n    );\n    emit MinDelayChange(_minDelay, newDelay);\n    _minDelay = newDelay;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
